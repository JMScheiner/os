
#ifndef REG_X239SB19
#define REG_X239SB19

#include <stdint.h>

/** 
* @brief  Images of the register state on entry to an interrupt handler. 
*  See Table 5-1 for some confusion about when an error code is pushed on
*  the stack and when it is not.
*
*  On top of that, it can be the two different versions in 5-4 for a total of
*     four different ways the stack can look depending on IOPL and the error code. 
*  
*  I'll assume that a change in IOPL is reflected somewhere useful so we know when
*     not to touch %esp and %ss.
*
*  QUESTION - Do user definied interrupts generate an error code??
*/
typedef struct REGSTATE_ERROR
{ 
   /* Generated by pusha: */
   uint32_t edi;         
   uint32_t esi;
   
   /* One of the ebps is fake....
    *  Correct one determined by extensive 0xfeedface'ing 
    */

   uint32_t ebp;
   uint32_t original_esp;
   
   /* uint32_t ebp; Why am I in the intel docs? */
   
   uint32_t ebx;
   uint32_t edx;
   uint32_t ecx;
   uint32_t eax;

   /* Generated by INT: */
   uint32_t errorcode;
   uint32_t eip;
   uint32_t cs;
   uint32_t eflags;
   uint32_t esp;
   uint32_t ss;
} regstate_error_t;

typedef struct REGSTATE
{ 
   /* Generated by pusha: */
   uint32_t edi;         
   uint32_t esi;
   uint32_t ebp;
   uint32_t original_esp;
   uint32_t ebx;
   uint32_t edx;
   uint32_t ecx;
   uint32_t eax;
   uint32_t eip;
   uint32_t cs;
   uint32_t eflags;
   uint32_t esp;
   uint32_t ss;
} regstate_t;

#define SYSCALL_ARG(regstate) \
	(regstate).esi

#endif /* end of include guard: REG_X239SB19 */


